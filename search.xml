<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Anti_Debug and Solution]]></title>
    <url>%2F2017%2F06%2F08%2FAnti-Debug-and-Solution%2F</url>
    <content type="text"><![CDATA[在逆向的过程中,难免会碰到一些应用带有Anti_Debug的功能,这里记录下了我在以往逆向的过程中碰到的一些反调试和对应的解决方案,分享给大家。 判断手机是否越狱123456789101112131415#通过_dyld_image_count 和 _dyld_get_image_name 来获取当前所有加载的dylib 并判断是否加载了MobileSubstrate.dylib#来判断手机是否已经越狱void dylibCheck() &#123; uint32_t count = _dyld_image_count(); char *substrate = "/Library/MobileSubstrate/MobileSubstrate.dylib"; for(uint32_t i = 0; i &lt; count; i++) &#123; const char *dyld = _dyld_get_image_name(i); if (strcmp(dyld,substrate)==0) &#123; NSLog(@"Substrate found!"); &#125; &#125; &#125; Solution 1234567891011121314151617181920212223242526272829uint32_t (*orig__dyld_image_count)(void) = _dyld_image_count;const char *(*orig__dyld_get_image_name)(uint32_t id) = _dyld_get_image_name;uint32_t replaced__dyld_image_count(void) &#123; NSString* preferenceFilePath = @PREFERENCEFILE; NSMutableDictionary* plist = [[NSMutableDictionary alloc] initWithContentsOfFile:preferenceFilePath]; int userCount = [[plist objectForKey:@"dyld_image_countValue"] intValue]; uint32_t count; uint32_t realCount = orig__dyld_image_count(); if (userCount &gt; 0 &amp;&amp; userCount &lt; 31337) &#123; count = (uint32_t) userCount; &#125;else &#123; count = realCount; &#125; return count; &#125;const char* replaced__dyld_get_image_name(uint32_t id) &#123; const char* realName = (const char *) orig__dyld_get_image_name(id); const char *fakeName = (const char *) orig__dyld_get_image_name(0); char *returnedName = (char *)realName; if (blockPath(realName)) &#123; returnedName = (char *)fakeName; &#125; return returnedName;&#125; 检查相关api函数是否被Hook12345//被hook函数后一般生成的代码地址是这种ldr x16, #8 //获取当前地址+8的内容存到x16寄存器种br x16 //跳转到x16寄存器 就是跳转到被hook以后的地址去了.long 0x****.long 0x00000001 //这里存放跳转地址 Solution 1234567891011//取一个函数的绝对地址 判断前0x10字节内是否存在hook的特征码int isFunctionHooked(void * funcptr) &#123; unsigned int * funcaddr = (unsigned int *) funcptr; if (funcptr) &#123; if (funcaddr[0] == 0x58000050 &amp;&amp; funcaddr[1] == 0xd61f0200 &amp;&amp; funcaddr[3] == 0x1) return 1; &#125; return 0; &#125; 阻止调试器附加调试系列ptrace ptrace is a syscall that provides a mechanism by which a parent process may observe and control the execution of another process. However, the ptrace syscall can be called by an iOS application in another way that prevents tracing from a debugger. When PT_DENY_ATTACH is passed as request, the application informs the operating system that it doesn’t want to be traced or debugged and will exit with a segmentation fault if traced. 12345678typedef int (*ptrace_ptr_t)(int _request, pid_t _pid, caddr_t _addr, int _data);#if !defined(PT_DENY_ATTACH) #define PT_DENY_ATTACH 31 #endifvoid* handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);ptrace_ptr_t ptrace_ptr = dlsym(handle, "ptrace");ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);dlclose(handle); Solution 123456789int (*orig_ptrace) (int request, pid_t pid, caddr_t addr, int data);int replaced_ptrace (int request, pid_t pid, caddr_t addr, int data)&#123; if (request == 31) &#123; request = -1; &#125; return orig_ptrace(request, pid, addr, data); &#125; syscallsysctl]]></content>
      <categories>
        <category>Anti</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
</search>