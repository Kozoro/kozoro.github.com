<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IOS Debug Cheatsheet]]></title>
    <url>%2F2017%2F06%2F08%2FIOS-Debug-Cheatsheet%2F</url>
    <content type="text"><![CDATA[command查找进程12ps aux | grep /Appps -e | grep /Applications 查找文件1grep -r findfile /System/Library/ 分离 fat binary12lipo -thin armv7 xxx.decrypted -out xxx_armv7.decryptedlipo -thin arm64 xxx.decrypted -out xxx_arm64.decrypted Class Dump1234class-dump --list-arches xxx.decryptedclass-dump -S -s -H xxx_armv7.decrypted -o dumparmv7class-dump -s -S -H --arch armv7 xxx.decrypted -o xxx LLDB参考 https://github.com/iosre/iOSAppReverseEngineering http://objccn.io/issue-19-2/ 帮助1help frame 打印UI结构12po [[[UIWindow keyWindow] rootViewController] _printHierarchy] (iOS 8)po [[UIWindow keyWindow] recursiveDescription] 栈信息12bt (backtrace)bt all (all threads) 断点123456br s -a 0x0023234fbreakpoint set -F "-[NSArray objectAtIndex:]"br s -a 0x02107730+0x000ab000 -c '(BOOL)[(NSString *)$r2 isEqualToString:@"snakeninny"]'b ptrace lookup12image lookup -address 0x1234image lookup -rn xx 远程调试1234platform select remote-iosprocess connect connect://127.0.0.1:3333 #链接debugserver *:1234 -a xxxx #附加debugserver -x backboard *:1234 xxxx #调试启动 ssh1ssh -lroot 127.0.0.1 -p2222 Info.plist输出bundle id1cat Info.plist | grep com. dumpdecrypted参考 https://github.com/stefanesser/dumpdecrypted 12chmod +x dumpdecrypted.dylibDYLD_INSERT_LIBRARIES=dumpdecrypted.dylib xxxx theos参考 https://github.com/theos/theos usbmuxd参考 https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz https://cgit.sukimashita.com/usbmuxd.git/ 1python tcprelay.py -t 22:2222 iproxy1iproxy 2222 22 &amp; iproxy 3333 1234 #映射端口]]></content>
      <categories>
        <category>Cheatsheet</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anti_Debug and Solution]]></title>
    <url>%2F2017%2F06%2F08%2FAnti-Debug-and-Solution%2F</url>
    <content type="text"><![CDATA[在逆向的过程中,难免会碰到一些应用带有Anti_Debug的功能,这里记录下了我在以往逆向的过程中碰到的一些反调试和对应的解决方案,分享给大家。 判断手机是否越狱123456789101112131415#通过_dyld_image_count 和 _dyld_get_image_name 来获取当前所有加载的dylib 并判断是否加载了MobileSubstrate.dylib#来判断手机是否已经越狱void dylibCheck() &#123; uint32_t count = _dyld_image_count(); char *substrate = "/Library/MobileSubstrate/MobileSubstrate.dylib"; for(uint32_t i = 0; i &lt; count; i++) &#123; const char *dyld = _dyld_get_image_name(i); if (strcmp(dyld,substrate)==0) &#123; NSLog(@"Substrate found!"); &#125; &#125; &#125; Solution 1234567891011121314151617181920212223242526272829uint32_t (*orig__dyld_image_count)(void) = _dyld_image_count;const char *(*orig__dyld_get_image_name)(uint32_t id) = _dyld_get_image_name;uint32_t replaced__dyld_image_count(void) &#123; NSString* preferenceFilePath = @PREFERENCEFILE; NSMutableDictionary* plist = [[NSMutableDictionary alloc] initWithContentsOfFile:preferenceFilePath]; int userCount = [[plist objectForKey:@"dyld_image_countValue"] intValue]; uint32_t count; uint32_t realCount = orig__dyld_image_count(); if (userCount &gt; 0 &amp;&amp; userCount &lt; 31337) &#123; count = (uint32_t) userCount; &#125;else &#123; count = realCount; &#125; return count; &#125;const char* replaced__dyld_get_image_name(uint32_t id) &#123; const char* realName = (const char *) orig__dyld_get_image_name(id); const char *fakeName = (const char *) orig__dyld_get_image_name(0); char *returnedName = (char *)realName; if (blockPath(realName)) &#123; returnedName = (char *)fakeName; &#125; return returnedName;&#125; 检查相关api函数是否被Hook12345//被hook函数后一般生成的代码地址是这种ldr x16, #8 //获取当前地址+8的内容存到x16寄存器种br x16 //跳转到x16寄存器 就是跳转到被hook以后的地址去了.long 0x****.long 0x00000001 //这里存放跳转地址 Solution 1234567891011//取一个函数的绝对地址 判断前0x10字节内是否存在hook的特征码int isFunctionHooked(void * funcptr) &#123; unsigned int * funcaddr = (unsigned int *) funcptr; if (funcptr) &#123; if (funcaddr[0] == 0x58000050 &amp;&amp; funcaddr[1] == 0xd61f0200 &amp;&amp; funcaddr[3] == 0x1) return 1; &#125; return 0; &#125; 阻止调试器附加调试系列ptrace ptrace is a syscall that provides a mechanism by which a parent process may observe and control the execution of another process. However, the ptrace syscall can be called by an iOS application in another way that prevents tracing from a debugger. When PT_DENY_ATTACH is passed as request, the application informs the operating system that it doesn’t want to be traced or debugged and will exit with a segmentation fault if traced. 12345678typedef int (*ptrace_ptr_t)(int _request, pid_t _pid, caddr_t _addr, int _data);#if !defined(PT_DENY_ATTACH) #define PT_DENY_ATTACH 31 #endifvoid* handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);ptrace_ptr_t ptrace_ptr = dlsym(handle, "ptrace");ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);dlclose(handle); Solution 123456789int (*orig_ptrace) (int request, pid_t pid, caddr_t addr, int data);int replaced_ptrace (int request, pid_t pid, caddr_t addr, int data)&#123; if (request == 31) &#123; request = -1; &#125; return orig_ptrace(request, pid, addr, data); &#125; syscall syscall 详细参数介绍 参考Kernel Syscalls iphone wiki 12//26 == ptracesyscall(26, 31, 0, 0); 注意 syscall 还可以以硬编码的形式直接写在程序当中,我们在遇到反调试并且找不到syscall调用的时候,可以查找下面的代码对应的特征码 12345678910111213141516171819202122#ifdef __arm__ asm volatile ( "mov r0, #31\n" "mov r1, #0\n" "mov r2, #0\n" "mov r12, #26\n" "svc #80\n"); #endif#ifdef __arm64__asm volatile ( "mov x0, #26\n" "mov x1, #31\n" "mov x2, #0\n" "mov x3, #0\n" "mov x16, #0\n" "svc #128\n"); #endif Solution 1234567891011121314static void* (*orig_syscall)(int code, va_list args);static void* my_syscall(int code, va_list args)&#123; int request; va_list newArgs; va_copy(newArgs, args); if(code == 26)&#123; request = (long)args; if(request == 31)&#123; NSLog(@"[AntiAntiDebug] - syscall call ptrace, and request is PT_DENY_ATTACH"); return nil; &#125; &#125; return (void*)orig_syscall(code, newArgs);&#125; sysctl123456789101112int mib[4];struct kinfo_proc info;size_t info_size = sizeof(info);info.kp_proc.p_flag = 0;mib[0] = CTL_KERN; mib[1] = KERN_PROC; mib[2] = KERN_PROC_PID; mib[3] = getpid();if (sysctl(mib, 4, &amp;info, &amp;info_size, NULL, 0) == -1) &#123; perror("perror sysctl"); exit(-1);&#125;return ((info.kp_proc.p_flag &amp; P_TRACED) != 0); Solution 12345678910111213141516static int (*orig_sysctl)(int * name, u_int namelen, void * info, size_t * infosize, void * newinfo, size_t newinfosize);static int my_sysctl(int * name, u_int namelen, void * info, size_t * infosize, void * newinfo, size_t newinfosize)&#123; int ret = orig_sysctl(name,namelen,info,infosize,newinfo,newinfosize); if(namelen == 4 &amp;&amp; name[0] == 1 &amp;&amp; name[1] == 14 &amp;&amp; name[2] == 1)&#123; struct kinfo_proc *info_ptr = (struct kinfo_proc *)info; if(info_ptr &amp;&amp; (info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) != 0)&#123; NSLog(@"[AntiAntiDebug] - sysctl query trace status."); info_ptr-&gt;kp_proc.p_flag ^= P_TRACED; if((info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) == 0)&#123; NSLog(@"[AntiAntiDebug] trace status reomve success!"); &#125; &#125; &#125; return ret;&#125; isatty The isatty function returns 1 to the target if the file descriptor given as parameter is attached to a debugger console, 0 otherwise 123456if (isatty(1)) &#123; NSLog(@"Being Debugged isatty");&#125;else&#123; NSLog(@"isatty() bypassed");&#125; Solution 12345int (*orig_isatty) (int fildes); int replaced_isatty (int fildes) &#123; return orig_isatty(0); &#125; 待添加]]></content>
      <categories>
        <category>Anti</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
</search>