<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017 Plan]]></title>
    <url>%2F2017%2F06%2F09%2F2017-Plan%2F</url>
    <content type="text"><![CDATA[发现自己最近几年来读的书越来越少了,特此开一个栏目用来计划以及记录每年预计要读得书籍和一些开源代码 2017 读书计划研究IOS以及MACOS下的一些攻防书籍 《iOS应用安全攻防实战》 《iOS应用安全权威指南》 《莱昂氏UNIX源代码分析》 《macOS软件安全与逆向分析》 待出版 相关读书笔记部分以及源代码理解部分会单独放出文章:D… 开源代码学习学习 分析 总结 fishhook Ios_Class_Guard 待添加]]></content>
      <categories>
        <category>plan</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Decrypting iOS applications using lldb]]></title>
    <url>%2F2017%2F06%2F08%2FDecrypting-iOS-applications-using-lldb%2F</url>
    <content type="text"><![CDATA[通过lldb or gdb decrypt ios application …. In Book Hacking iOS Applications]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mach-o Format Executable File]]></title>
    <url>%2F2017%2F06%2F08%2FMach-o-Format-Executable-File%2F</url>
    <content type="text"><![CDATA[参考 https://github.com/kpwn/iOSRE/blob/master/wiki/Mach-O.md mach-o/loader.h Mach-O文件格式和程序从加载到执行过程]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kill SSL And Logs]]></title>
    <url>%2F2017%2F06%2F08%2FKill-SSL-And-Logs%2F</url>
    <content type="text"><![CDATA[原理通过Hook SSLRead SSLWrite 在数据处理之前我们打印出来 来进行分析详细处理过程 见下面代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248#import &lt;CoreFoundation/CoreFoundation.h&gt;#include &lt;substrate.h&gt;#import &lt;Foundation/Foundation.h&gt;#import &lt;zlib.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;dlfcn.h&gt;#include &lt;MacTypes.h&gt;#include "NSUtil.h"BOOL g_bIsPost = FALSE;void SSLLogData(const void *data, size_t dataLength,void *returnAddress = __builtin_return_address(0))&#123; if (data == nil || dataLength == 0) return; static int s_index = 0; static NSString *_logDir = nil; if (_logDir == nil) &#123; NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; NSString *appCurName = [infoDictionary objectForKey:@"CFBundleIdentifier"]; NSLog(@"IOSTQ app name :%@", appCurName); if ([appCurName isEqualToString:@"com.apple.AppStore"] ) &#123; NSURL *url = [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]; NSString* document = [url absoluteString]; NSRange prefixPath = [document rangeOfString:@"file://"]; NSString* nsAppstorePath = [document substringFromIndex:prefixPath.length]; _logDir = [[NSString alloc] initWithFormat:@"%@%@.req", nsAppstorePath,NSProcessInfo.processInfo.processName]; NSLog(@"IOSTQ file path:%@",_logDir); &#125; else &#123; _logDir = [[NSString alloc] initWithFormat:@"/tmp/time.req"]; &#125; [[NSFileManager defaultManager] createDirectoryAtPath:_logDir withIntermediateDirectories:YES attributes:nil error:nil]; &#125; NSData *httpData = [[NSData alloc] initWithBytesNoCopy:(void*)data length:dataLength freeWhenDone:0]; NSString *file = nil; NSTimeInterval time = [[NSDate date] timeIntervalSince1970]; long long dTime = [[NSNumber numberWithDouble:time] longLongValue]; if ( memcmp(data, "GET ", 4) == 0) &#123; NSString *nsRow = [[NSString alloc] initWithData:httpData encoding:NSUTF8StringEncoding]; NSRange objBegin = [nsRow rangeOfString:@" "]; NSRange objRaw = [nsRow rangeOfString:@"\r\n"]; NSRange objEnd = [nsRow rangeOfString:@" HTTP/1.1"]; if (objRaw.location &gt; objEnd.location) &#123; unsigned long nPos = objBegin.location + objBegin.length; unsigned long nLen = objEnd.location - nPos; NSString* nsExePath = [nsRow substringWithRange:NSMakeRange(nPos,nLen)]; //file = [NSString stringWithFormat:@"%@/%03d-GET-%@.txt", _logDir, s_index++, NSUrlPath(nsExePath)]; //1.1日修改下抓取chunked模式包 file = [NSString stringWithFormat:@"%@/%llu-%03d-%@-GET-%@.txt", _logDir,dTime,s_index++,NSProcessInfo.processInfo.processName, NSUrlPath(nsExePath)]; //file = [NSString stringWithFormat:@"%@/%llu-%03d-%@-GET.txt", _logDir,dTime,s_index++,NSProcessInfo.processInfo.processName]; &#125; [nsRow release]; &#125; else if ( memcmp(data, "POST ", 5) == 0) &#123; g_bIsPost = TRUE; NSString *nsRow = [[NSString alloc] initWithData:httpData encoding:NSUTF8StringEncoding]; NSRange objBegin = [nsRow rangeOfString:@" "]; NSRange objRaw = [nsRow rangeOfString:@"\r\n"]; NSRange objEnd = [nsRow rangeOfString:@" HTTP/1.1"]; if (objRaw.location &gt; objEnd.location) &#123; unsigned long nPos = objBegin.location + objBegin.length; unsigned long nLen = objEnd.location - nPos; NSString* nsExePath = [nsRow substringWithRange:NSMakeRange(nPos,nLen)]; file = [NSString stringWithFormat:@"%@/%llu-%03d-%@-POST-%@.txt", _logDir, dTime,s_index++,NSProcessInfo.processInfo.processName,NSUrlPath(nsExePath)]; //file = [NSString stringWithFormat:@"%@/%llu-%03d-%@-POST.txt", _logDir, dTime,s_index++,NSProcessInfo.processInfo.processName]; &#125; [nsRow release]; &#125; else &#123; if (g_bIsPost) &#123; g_bIsPost = FALSE; file = [NSString stringWithFormat:@"%@/%llu-%03d-%@-POST-PARAMS.txt", _logDir,dTime,s_index-1,NSProcessInfo.processInfo.processName]; &#125; else &#123; file = [NSString stringWithFormat:@"%@/%llu-%03d-%@.DATA", _logDir, dTime,s_index++,NSProcessInfo.processInfo.processName]; &#125; &#125; if (file != nil) &#123; NSLog(@"IOSTQ---%@",file); [httpData writeToFile:file atomically:NO]; &#125; else &#123; NSLog(@"IOSTQ---nil"); &#125; [httpData release];&#125;void LogData(const void *data, size_t dataLength,void *returnAddress = __builtin_return_address(0))&#123; if (data == nil || dataLength == 0) return; static int s_index = 0; static NSString *_logDir = nil; if (_logDir == nil) &#123; _logDir = [[NSString alloc] initWithFormat:@"/tmp/%@.req", NSProcessInfo.processInfo.processName]; [[NSFileManager defaultManager] createDirectoryAtPath:_logDir withIntermediateDirectories:YES attributes:nil error:nil]; &#125; Dl_info info = &#123;0&#125;; dladdr(returnAddress, &amp;info); BOOL txt = !memcmp(data, "GET ", 4) || !memcmp(data, "POST ", 5); NSString *str = [NSString stringWithFormat:@"FROM %s(%p)-%s(%p=&gt;%#08lx)\n&lt;%@&gt;\n\n", info.dli_fname, info.dli_fbase, info.dli_sname, info.dli_saddr, (long)info.dli_saddr-(long)info.dli_fbase-0x1000, [NSThread callStackSymbols]]; NSMutableData *dat = [NSMutableData dataWithData:[str dataUsingEncoding:NSUTF8StringEncoding]]; [dat appendBytes:data length:dataLength]; NSString *file = [NSString stringWithFormat:@"%@/DATA.%03d.%@", _logDir, s_index++, txt ? @"txt" : @"dat"]; [dat writeToFile:file atomically:NO];&#125;void LogRequest(NSURLRequest *request, void *returnAddress = __builtin_return_address(0))&#123; static int s_index = 0; static NSString *_logDir = nil; static std::vector&lt;NSURLRequest *&gt; _requests; if (_logDir == nil) &#123; _logDir = [[NSString alloc] initWithFormat:@"/tmp/%@.req", NSProcessInfo.processInfo.processName]; [[NSFileManager defaultManager] createDirectoryAtPath:_logDir withIntermediateDirectories:YES attributes:nil error:nil]; &#125; if ([request respondsToSelector:@selector(HTTPMethod)]) &#123; if (std::find(_requests.begin(), _requests.end(), request) == _requests.end()) &#123; _requests.push_back(request); if (_requests.size() &gt; 1024) &#123; _requests.erase(_requests.begin(), _requests.begin() + 512); &#125; Dl_info info = &#123;0&#125;; dladdr(returnAddress, &amp;info); NSString *str = [NSString stringWithFormat:@"FROM %s(%p)-%s(%p=&gt;%#08lx)\n&lt;%@&gt;\n%@: %@\n%@\n\n", info.dli_fname, info.dli_fbase, info.dli_sname, info.dli_saddr, (long)info.dli_saddr-(long)info.dli_fbase-0x1000, [NSThread callStackSymbols], request.HTTPMethod, request.URL.absoluteString, request.allHTTPHeaderFields ? request.allHTTPHeaderFields : @""]; NSLog(@"HTTPEEK REQUEST: %@", str); NSString *file = [NSString stringWithFormat:@"%@/%03d=%@.txt", _logDir, s_index++, NSUrlPath([request.URL.host stringByAppendingString:request.URL.path])]; if (request.HTTPBody.length &amp;&amp; request.HTTPBody.length &lt; 10240) &#123; NSString *str2 = [[NSString alloc] initWithData:request.HTTPBody encoding:NSUTF8StringEncoding]; if (str2) &#123; [[str stringByAppendingString:str2] writeToFile:file atomically:NO encoding:NSUTF8StringEncoding error:nil]; return; &#125; &#125; [str writeToFile:file atomically:NO encoding:NSUTF8StringEncoding error:nil]; [request.HTTPBody writeToFile:[file stringByAppendingString:@".dat"] atomically:NO]; &#125; &#125;&#125;OSStatus (*originalSSLRead)(SSLContextRef context, void *data, size_t dataLength, size_t *processed);OSStatus replacedSSLRead(SSLContextRef context, void *data, size_t dataLength, size_t *processed)&#123; OSStatus ret = originalSSLRead(context, data, dataLength, processed); SSLLogData(data, *processed); return ret;&#125;OSStatus (*originalSSLWrite)(SSLContextRef context, const void *data, size_t dataLength, size_t *processed);OSStatus replacedSSLWrite(SSLContextRef context, const void *data, size_t dataLength, size_t *processed)&#123; SSLLogData(data, dataLength); OSStatus ret = originalSSLWrite(context, data, dataLength, processed); return ret;&#125;%ctor&#123; MSHookFunction((void *)SSLRead, (void *)replacedSSLRead, (void **)&amp;originalSSLRead); MSHookFunction((void *)SSLWrite, (void *)replacedSSLWrite, (void **)&amp;originalSSLWrite);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[IOS Debug Cheatsheet]]></title>
    <url>%2F2017%2F06%2F08%2FIOS-Debug-Cheatsheet%2F</url>
    <content type="text"><![CDATA[command查找进程 12ps aux | grep /Appps -e | grep /Applications 查找文件1grep -r findfile /System/Library/ 分离 fat binary12lipo -thin armv7 xxx.decrypted -out xxx_armv7.decryptedlipo -thin arm64 xxx.decrypted -out xxx_arm64.decrypted Class Dump1234class-dump --list-arches xxx.decryptedclass-dump -S -s -H xxx_armv7.decrypted -o dumparmv7class-dump -s -S -H --arch armv7 xxx.decrypted -o xxx LLDB参考 https://github.com/iosre/iOSAppReverseEngineering http://objccn.io/issue-19-2/ 帮助1help frame 打印UI结构1234po [[[UIWindow keyWindow] rootViewController] _printHierarchy] (iOS 8)po [[UIWindow keyWindow] recursiveDescription]po [choose(SBApplication)[0] _ivarDescription].toString()po [choose(SBApplicationController)[0] _methodDescription].toString() 栈信息12bt (backtrace)bt all (all threads) 断点1234br s -a 0x0023234fbreakpoint set -F "-[NSArray objectAtIndex:]"br s -a 0x02107730+0x000ab000 -c '(BOOL)[(NSString *)$r2 isEqualToString:@"snakeninny"]'b ptrace lookup1234567image lookup -address 0x1234image lookup -rn xximage lookup -a 表达式、image list对于有调试符号的这样使用image lookup -r -n &lt;FUNC_REGEX&gt;对于无调试符号的这样使用：image lookup -r -s &lt;FUNC_REGEX&gt; DUMP内存到本地123456789memory read 0x35f1c 0x35f46 -outfile /tmp/test.txt // 将内存区域保存到文件默认情况下，memory read 只能读取 1024字节数据 解决方法：加－force参数memory read 0x1000 0x3000 -outfile /tmp/test.txt -force或者:memory read 0x1000 -outfile /tmp/test.txt -count 0x2000 -forcememory read $x0(寄存器) -outfile /tmp/test.txt -count 0x2000 -forcememory read 0x1000 0x3000 -outfile /tmp/test.bin --binary -force //二进制输出 远程调试1234platform select remote-iosprocess connect connect://127.0.0.1:3333 #链接debugserver *:1234 -a xxxx #附加debugserver -x backboard *:1234 xxxx #调试启动 ssh1ssh -lroot 127.0.0.1 -p2222 Info.plist输出bundle id1cat Info.plist | grep com. hook all process1234567&#123; Filter = &#123; Bundles = ( "com.apple.Security", ); &#125;;&#125; dumpdecrypted参考 https://github.com/stefanesser/dumpdecrypted 12chmod +x dumpdecrypted.dylibDYLD_INSERT_LIBRARIES=dumpdecrypted.dylib xxxx theos参考 https://github.com/theos/theos usbmuxd参考 https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz https://cgit.sukimashita.com/usbmuxd.git/ 1python tcprelay.py -t 22:2222 iproxy1iproxy 2222 22 &amp; iproxy 3333 1234 #映射端口 Git1git clone --recursive hexo Blog12hexo dhexo g]]></content>
      <categories>
        <category>Cheatsheet</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anti_Debug and Solution]]></title>
    <url>%2F2017%2F06%2F08%2FAnti-Debug-and-Solution%2F</url>
    <content type="text"><![CDATA[在逆向的过程中,难免会碰到一些应用带有Anti_Debug的功能,这里记录下了我在以往逆向的过程中碰到的一些反调试和对应的解决方案,分享给大家。 判断手机是否越狱123456789101112131415#通过_dyld_image_count 和 _dyld_get_image_name 来获取当前所有加载的dylib 并判断是否加载了MobileSubstrate.dylib\#来判断手机是否已经越狱void dylibCheck() &#123; uint32_t count = _dyld_image_count(); char *substrate = "/Library/MobileSubstrate/MobileSubstrate.dylib"; for(uint32_t i = 0; i &lt; count; i++) &#123; const char *dyld = _dyld_get_image_name(i); if (strcmp(dyld,substrate)==0) &#123; NSLog(@"Substrate found!"); &#125; &#125; &#125; Solution 1234567891011121314151617181920212223242526272829uint32_t (*orig__dyld_image_count)(void) = _dyld_image_count;const char *(*orig__dyld_get_image_name)(uint32_t id) = _dyld_get_image_name;uint32_t replaced__dyld_image_count(void) &#123; NSString* preferenceFilePath = @PREFERENCEFILE; NSMutableDictionary* plist = [[NSMutableDictionary alloc] initWithContentsOfFile:preferenceFilePath]; int userCount = [[plist objectForKey:@"dyld_image_countValue"] intValue]; uint32_t count; uint32_t realCount = orig__dyld_image_count(); if (userCount &gt; 0 &amp;&amp; userCount &lt; 31337) &#123; count = (uint32_t) userCount; &#125;else &#123; count = realCount; &#125; return count; &#125;const char* replaced__dyld_get_image_name(uint32_t id) &#123; const char* realName = (const char *) orig__dyld_get_image_name(id); const char *fakeName = (const char *) orig__dyld_get_image_name(0); char *returnedName = (char *)realName; if (blockPath(realName)) &#123; returnedName = (char *)fakeName; &#125; return returnedName;&#125; 检查相关api函数是否被Hook12345//被hook函数后一般生成的代码地址是这种ldr x16, #8 //获取当前地址+8的内容存到x16寄存器种br x16 //跳转到x16寄存器 就是跳转到被hook以后的地址去了.long 0x****.long 0x00000001 //这里存放跳转地址 Solution 1234567891011//取一个函数的绝对地址 判断前0x10字节内是否存在hook的特征码int isFunctionHooked(void * funcptr) &#123; unsigned int * funcaddr = (unsigned int *) funcptr; if (funcptr) &#123; if (funcaddr[0] == 0x58000050 &amp;&amp; funcaddr[1] == 0xd61f0200 &amp;&amp; funcaddr[3] == 0x1) return 1; &#125; return 0; &#125; 阻止调试器附加调试系列ptrace ptrace is a syscall that provides a mechanism by which a parent process may observe and control the execution of another process. However, the ptrace syscall can be called by an iOS application in another way that prevents tracing from a debugger. When PT_DENY_ATTACH is passed as request, the application informs the operating system that it doesn’t want to be traced or debugged and will exit with a segmentation fault if traced. 12345678typedef int (*ptrace_ptr_t)(int _request, pid_t _pid, caddr_t _addr, int _data);#if !defined(PT_DENY_ATTACH) #define PT_DENY_ATTACH 31 #endifvoid* handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);ptrace_ptr_t ptrace_ptr = dlsym(handle, "ptrace");ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);dlclose(handle); Solution 123456789int (*orig_ptrace) (int request, pid_t pid, caddr_t addr, int data);int replaced_ptrace (int request, pid_t pid, caddr_t addr, int data)&#123; if (request == 31) &#123; request = -1; &#125; return orig_ptrace(request, pid, addr, data); &#125; syscall syscall 详细参数介绍 参考Kernel Syscalls iphone wiki 12//26 == ptracesyscall(26, 31, 0, 0); 注意 syscall 还可以以硬编码的形式直接写在程序当中,我们在遇到反调试并且找不到syscall调用的时候,可以查找下面的代码对应的特征码 12345678910111213141516171819202122#ifdef __arm__ asm volatile ( "mov r0, #31\n" "mov r1, #0\n" "mov r2, #0\n" "mov r12, #26\n" "svc #80\n"); #endif#ifdef __arm64__asm volatile ( "mov x0, #26\n" "mov x1, #31\n" "mov x2, #0\n" "mov x3, #0\n" "mov x16, #0\n" "svc #128\n"); #endif Solution 1234567891011121314static void* (*orig_syscall)(int code, va_list args);static void* my_syscall(int code, va_list args)&#123; int request; va_list newArgs; va_copy(newArgs, args); if(code == 26)&#123; request = (long)args; if(request == 31)&#123; NSLog(@"[AntiAntiDebug] - syscall call ptrace, and request is PT_DENY_ATTACH"); return nil; &#125; &#125; return (void*)orig_syscall(code, newArgs);&#125; sysctl123456789101112int mib[4];struct kinfo_proc info;size_t info_size = sizeof(info);info.kp_proc.p_flag = 0;mib[0] = CTL_KERN; mib[1] = KERN_PROC; mib[2] = KERN_PROC_PID; mib[3] = getpid();if (sysctl(mib, 4, &amp;info, &amp;info_size, NULL, 0) == -1) &#123; perror("perror sysctl"); exit(-1);&#125;return ((info.kp_proc.p_flag &amp; P_TRACED) != 0); Solution 12345678910111213141516static int (*orig_sysctl)(int * name, u_int namelen, void * info, size_t * infosize, void * newinfo, size_t newinfosize);static int my_sysctl(int * name, u_int namelen, void * info, size_t * infosize, void * newinfo, size_t newinfosize)&#123; int ret = orig_sysctl(name,namelen,info,infosize,newinfo,newinfosize); if(namelen == 4 &amp;&amp; name[0] == 1 &amp;&amp; name[1] == 14 &amp;&amp; name[2] == 1)&#123; struct kinfo_proc *info_ptr = (struct kinfo_proc *)info; if(info_ptr &amp;&amp; (info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) != 0)&#123; NSLog(@"[AntiAntiDebug] - sysctl query trace status."); info_ptr-&gt;kp_proc.p_flag ^= P_TRACED; if((info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) == 0)&#123; NSLog(@"[AntiAntiDebug] trace status reomve success!"); &#125; &#125; &#125; return ret;&#125; isatty The isatty function returns 1 to the target if the file descriptor given as parameter is attached to a debugger console, 0 otherwise 123456if (isatty(1)) &#123; NSLog(@"Being Debugged isatty");&#125;else&#123; NSLog(@"isatty() bypassed");&#125; Solution 12345int (*orig_isatty) (int fildes); int replaced_isatty (int fildes) &#123; return orig_isatty(0); &#125; 待添加]]></content>
      <categories>
        <category>Anti</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
</search>